{"meta":{"title":"BIGGILL","subtitle":null,"description":"平时的摘抄和自己的胡说八道","author":"BIGGILL","url":"https://tangzeng.github.io","root":"/"},"pages":[],"posts":[{"title":"iOS 内存分配、管理和泄漏检测","slug":"iOS 内存分配、管理和MLeakFinder源码分析","date":"2019-05-09T06:29:19.000Z","updated":"2020-04-25T23:58:50.109Z","comments":true,"path":"2019/05/09/iOS 内存分配、管理和MLeakFinder源码分析/","link":"","permalink":"https://tangzeng.github.io/2019/05/09/iOS 内存分配、管理和MLeakFinder源码分析/","excerpt":"","text":"1. 内存分配分类physical memory：物理内存就是实际的物理内存，现在的操作系统都不会直接去操作物理内存 virtual memory：虚拟内存每当启动一个进程的时候都会创建一个logical address space，也叫虚拟地址空间，和物理内存或者其他应用程序的虚拟地址都不对称。 resident memory 常驻内存程序占用的物理内存 clean memory 干净内存可以被重新创建利用的内存, 在iOS的应用有: system framework 二进制可执行文件 内存映射文件 当APP链接到框架时，clean memory将增加框架二进制文件的大小。但大多数时候，只有部分二进制文件才真正加载到物理内存中。因为clean memory是只读的，APP之间可以共享framework以及library。 dirty memory 脏内存无法由系统重新创建利用的内存。当存在内存压力时，系统将清理回收一些clean memory，当再次需要内存时，系统将重新创建它们。但是对于dirty memory, 系统无法卸载它们，并且iOS没有交换机制，因此脏内存将始终保存在物理内存中，直到达到一定限度，然后您的应用程序将被终止才能被系统回收。 resident memory 常驻内存就是是真正加载到physical memory中的内存12345virtual memory = clean memory + dirty memory.resident memory = dirty memory + clean memory that loaded in physical memoryvirtual memory == (clean memory + dirty memory) &gt; resident memory &gt; dirty memory 内存分页计算机会对虚拟内存地址空间（32位为4G）分页产生页（Page），对物理内存地址空间分页产生页帧（Page Frame），这个页和页帧的大小是一样大的（老的设备上都是4Kb)。计算机的MMU上有一个页表（Page Table），就是映射虚拟内存页到物理内存页的，更确切的说是页号到页帧号的映射，而且是一对一的映射。由于一般情况下虚拟内存 &gt; 物理内存， 因此虚拟内存页的个数 &gt; 物理内存页帧的个数, 因此并不是所有的 Page 都会映射到物理内存中。每个虚拟内存的Page 有三种状态： Nonresident 是否 Resident 是一个 Page 状态的重要标识，如果 Page 被映射到内存里了，这个 Page 就是 Resident 状态，否则就是 Nonresident 状态； Resident and clean clean memory that loaded in physical memory。这种 Page 由于是加载自不可变的文件，因此可以在物理内存紧张时被 iOS 自动 unload 出去，并且在需要的时候再重新从原来的文件加载到内存中。 Resident and dirty 凡是非 clean 的 Page 都是 dirty 的，它们的共同特点是 Page 在闪存中没有对应的文件，比如通过 alloc 在堆上创建的内存空间，已经解压的图片，database caches 等。dirty memory 不能被操作系统交换出去，只有在进程被杀死的时候才能被回收，因此在系统发生内存告警时，如果进程创建了大量的 dirty memory，那么将很有可能被 kill 掉。 举例说明 Malloc 分配内存1234567// clean memorychar *buf = malloc(100*1024*1024)// dirty memoryfor(int i=0; i &lt; 3*1024*1024; ++i)&#123; buf[i] = rand()&#125; 通过Intruments的Alloctions和VM tracker可以分析，首先申请了100M的虚拟内存，但是你只要不用，虚拟内存中的pages就处于Nonresident状态。后来for循环中，我们进行读写，操作系统就会分配3M的物理内存，这个时候该内存空间就处于Resident and dirty状态，而其他97M的虚拟内存空间是处于Nonresident状态。 我们的程序平时大多都是直接访问的虚拟地址，虚拟地址需要经过映射才能访问到物理内存地址，映射过程： MMU（内存管理单元）的两个寄存器在中间起到了强大的作用，界限寄存器用来判断是否越界，如果没有越界就会加上基址寄存器的值（页帧号和偏移量），转换为物理内存地址。 如果越界了，就说明物理内存已经不够用，需要操作系统腾出空间。 操作系统有个页面失效（page fault）功能。操作系统找到一个最少使用的页帧，让他失效，并采用swap技术把它写入磁盘，随后把需要访问的页放到页帧中，并修改页表中的映射，然后就能实现物理内存地址的转换了。 ps：swap：将数据从物理内存移到磁盘被称为页面换出；将数据从磁盘移到物理内存被称为页面换入 对于iOS来说，由于移动设备的闪存容量很有限，并且闪存的频繁读写很降低寿命，因此是无Swap机制的。所以当越界的时候，会直接报错， 并通过Jetsam来Kill掉优先级低的进程，。 Jetsam: 低内存处理机制Jetsam，这是一个基于优先级队列的机制。优先级由低到高是：IDLE（空闲）-&gt; BACKGROUND- &gt; FOREGROUND, 依次类推。当内存过低的时候，就会在队列中进行广播，希望大家尽量释放内存，如果一段时间后，仍然内存不够，就会开始Kill进程，直到内存够用。 Jetsam里面有表明每个进程都有一个”high water mark” （HWM），超过这个值时就会触发 Jetsam 机制去 kill 这个进程。这时我就很好奇了，这个 HWM 的值究竟是多少呢？ 1GB 的设备的HWM大致对应650M左右XNU源码JetSam探析iOS OOMiOS Memory Deep DiveHandling low memory conditions in iOS and Mavericks 对于开发者来说，要想减少应用因内存告警被系统杀掉，应做到以下几点： 该尽可能减少 dirty 内存的创建 要尽量保证 dirty 内存用完之后及时释放(ARC) 及时处理系统内存告警通知，释放掉大量占用内存并且可重建的对象 在发生内存告警时，不再持续申请内存，更不能申请较大块的内存 2. iOS 内存管理1. objective-c 对象的内存分配12NSString *someString = @&quot;Some String&quot;;NSString *anotherString = someString; 我们表明上看起来似乎创建了两个NSString对象，其实它们二者是复用的关系, 上述代码只创建了一个NSString对象@”Some String”，它分配在堆中，需要进行内存管理。注意，我们并不是说这个字符串常量在堆上，而是创建一个OC对象需要的内存开销是在堆上，普通的字符串常量存在数据段的.rodata区。 someString和anotherString是两个指针**，它们存在于栈中，栈的管理由系统控制。这两个内存的大小刚好能够分别存下一个指针(在32位CPU上是4字节，在64位上是8字节)，而且两个内存中的值是一样的，即两个指针的值是一样的，于是两个指针指向同一个堆内存区域，从而导致someString和anotherString**这两个指针指向的是相同的字符串实例。 总结： someString和anotherString分配在栈上，无需我们控制。NSString: @”Some String”分配在堆上，需要我们进行内存管理。根据OC的内存管理规则， someString和anotherString 都引用了NSString: @”Some String”， 因此retainCount = 2, 当someString和anotherString两个指针被系统自动释放之后，NSString: @”Some String” 的retainCount = 0， 根据引用计数规则，这个对象会被回收。 OC对于普通的非对象类型的变量，比如CGRect结构，它们也会使用栈空间，而非对象类型所用的堆空间 2.自动释放池@autoreleasepoolOC对象的生命周期取决于引用计数，MRC模式下有两种方式可以释放对象：一种是直接调用release释放；另一种是调用autorelease将对象加入自动释放池中。自动释放池用于存放那些需要在稍后某个时刻释放的对象。 自动释放池的创建如果没有自动释放池而给对象发送autorelease消息，将会收到控制台报错。但一般我们无需担心自动释放池的创建问题。 我们的Mac以及iOS系统会自动创建一些线程，例如主线程和GCD中的线程，都默认拥有自动释放池。每次执行 “事件循环”(event loop)时，就会将其清空 因此我们一般不需要手动创建自动释放池，通常只有一个地方需要它，那就是在main()函数里，如下： 12345int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; 这个main()函数里面的池并非必需。因为块的末尾是应用程序的终止处，即便没有这个自动释放池，也会由操作系统来释放。但是这些由UIApplicationMain函数所自动释放的对象就没有池可以容纳了，系统会发出警告。因此，这里的池可以理解成最外围捕捉全部自动释放对象所用的池。 内存中的堆和栈到底是什么) iOS 内存管理 @autoreleasepool 原理先看一个例子： 12345for (int i = 0; i &lt; 1000000; i++) &#123; NSString *str = @&quot;abc&quot;; str = [str lowercaseString]; str = [str stringByAppendingString:@&quot;xyz&quot;]; &#125; 这段代码在执行的时候，会出现内存突然升高的问题，可能导致crash，因为str在调用完方法后依然处于存活状态，因为目前它们都在自动释放池里，等待回收。但自动释放池却要等到该线程执行下一次事件循环时才会清空，这就意味着在执行for循环时，会有持续不断的新的临时对象被创建出来，并加入自动释放池。由于这些临时变量是存在heap里面的（他们的指针是在stack里面），因此如果一直循环下去，heap大小会越来越大，要等到结束for循环才会释放。 1234567for (int i = 0; i &lt; 1000000; i++) &#123; @autoreleasepool &#123; NSString *str = @&quot;abc&quot;; str = [str lowercaseString]; str = [str stringByAppendingString:@&quot;xyz&quot;]; &#125; &#125; 自动释放池的机制就像“栈”。系统创建好autoreleasepool之后，将其压入栈中，而清空自动释放池相当于将池从栈中弹出。将对象放入@autoreleasepool代码块中，就等于将其放入位于栈顶，系统在块的末尾将这些对象优先回收掉。每个循环结束后，内存用量不会累加升高。 3. 关于retainCount误区一[object retainCount] 似乎可以返回某对象的保留计数，其实即便在MRC下，retainCount在实际编程过程中也并没有什么用。首要原因在于：它返回的保留计数只是某个时间点上的值 例如： 123while ([object retainCount]) &#123; [object release];&#125; 其中存在两个错误：第一个就是没有考虑到自动释放操作，只是不停地release，直到对象被系统回收。假如此对象在自动释放池里，那么稍后系统在清理空池子时还要仔把它释放一次，这将导致程序崩溃。 第二个错误就是：retainCount可能永远也不会减少到0。因为有时候系统会优化对象的释放行为，在保留计数还是1的时候就把它回收了。最后一次执行 release 时，系统知道马上就要回收内存了，就没有必要再将 retainCount 减 1 了，因为不管减不减 1，该对象都肯定会被回收，而对象被回收后，它的所有的内存区域，包括 retainCount 值也变得没有意义。不将这个值从 1 变成 0，可以减少一次内存的写操作，加速对象的回收。只有在系统不打算这么优化时，计数值才会递减址0。 误区二如果我们打印一些字符串或者数值对象的retainCount，如下代码： 12345678NSString *string = @&quot;Apple&quot;;NSLog(@&quot;string retainCount: %lu&quot;, (unsigned long)[string retainCount]); NSNumber *numberI = @1;NSLog(@&quot;numberI retainCount: %lu&quot;, (unsigned long)[numberI retainCount]); NSNumber *numberF = @3.14f;NSLog(@&quot;numberF retainCount: %lu&quot;, (unsigned long)[numberF retainCount]); 其输出将会如下： 1232016-12-04 20:04:51.007 tmp[1522:138528] string retainCount: 184467440737095516152016-12-04 20:04:51.008 tmp[1522:138528] numberI retainCount: 92233720368547758072016-12-04 20:04:51.008 tmp[1522:138528] numberF retainCount: 1 我们发现结果非常奇怪。怎么回事呢？ 第一个string的保留计数其实为2的64次方-1，而第二个numberI是2的63次方-1。二者皆为“单例对象”(singleton object)，所以保留计数都很大。 系统会尽可能地把NSString实现成单例对象。像上述代码中的字符串，其实是一个编译期常量，编译器会把NSString对象所表示的数据放到应用程序的二进制文件里，这样的话，运行程序时就能直接用了。这一点对应到底层的话，隶属于程序的可执行文件中数据段的.rodata小段的作用，如果你阅读过开头笔者提到的《内存中的堆和栈到底是什么》这篇文章，应该可以很容易理解。 NSNumber也类似，它使用了一种叫做“标签指针”(tagged pointer)的概念来标注特定类型的数值。关于tagged pointer，可以阅读这篇唐巧的文章：深入理解Tagged Pointer。 tagged pointer不使用NSNumber对象，而是把数值有关的全部消息都放在指针值里面。运行期系统会在消息派发期间检测到这种标签指针，并对它执行相应操作，使其行为看上去和真正的NSNumber对象一样。这种优化只在某些场合使用，比如上述代码中的浮点数对象就没有优化，所以保留计数就是1。 上述的这种单例对象，其保留计数绝对不会变。这种对象的保留及释放操作都是“空操作”(noop)。 循环引用（Reference Cycle）问题引用计数这种管理内存的方式虽然很简单，但是有一个比较大的瑕疵，即它不能很好的解决循环引用问题。如下图所示：对象 A 和对象 B，相互引用了对方作为自己的成员变量，只有当自己销毁时，才会将成员变量的引用计数减 1。因为对象 A 的销毁依赖于对象 B 销毁，而对象 B 的销毁与依赖于对象 A 的销毁，这样就造成了我们称之为循环引用（Reference Cycle）的问题，这两个对象即使在外界已经没有任何指针能够访问到它们了，它们也无法被释放。 弱引用弱引用虽然持有对象，但是并不增加引用计数，这样就避免了循环引用的产生。它的实现原理：系统对于每一个有弱引用的对象，都维护一个表来记录它所有的弱引用的指针地址。这样，当一个对象的引用计数为 0 时，系统就通过这张表，找到所有的弱引用指针，继而把它们都置成 nil。 3. 内存泄漏的检测和MLeaksFinder1、MLeakFinder简介· 背景平常我们都会用 Instrument 的 Leaks / Allocations 进行内存泄露的排查。但是 Leaks / Allocations 用起来会比较麻烦，而且是一个被动型工具，需要我们事先猜测哪些地方发生了内存泄漏才会去用它们去定位，而MLeaksFinder用起来会更简单直白，更改完代码后一运行即能发现，当发生内存泄露时，MLeaksFinder 会主动触发断言，弹出alert准确的告诉你哪个对象泄露了, 结合Memory Graph 能迅速定位内存泄漏的代码。 · 用法把 MLeaksFinder 目录下的文件添加到你的项目中，就可以在运行时（debug 模式下）帮助你检测项目里的内存泄露了，无需修改任何业务逻辑代码，而且只在 debug 下开启，完全不影响你的 release 包。 中断言时，控制台会有如下提示，View-ViewController stack 从上往下看，该 stack 告诉你，MyTableViewController 的 UITableView 的 subview UITableViewWrapperView 的 subview MyTableViewCell 没被释放。而且，这里我们可以肯定的是 MyTableViewController，UITableView，UITableViewWrapperView 这三个已经成功释放了。 12345678*** Terminating app due to uncaught exception &apos;NSInternalInconsistencyException&apos;, reason: &apos;Possibly Memory Leak.In case that MyTableViewCell should not be dealloced, override -willDealloc in MyTableViewCell by returning NO.View-ViewController stack: ( MyTableViewController, UITableView, UITableViewWrapperView, MyTableViewCell)&apos; · 原理MLeaksFinder 一开始从 UIViewController 入手。我们知道，正常情况下当一个 UIViewController 被 pop 或 dismiss 后，该 UIViewController 包括它的 view，view 的 subviews 等等将很快被释放（除非你把它设计成单例，或者持有它的强引用，但一般很少这样做）。于是，我们只需在一个 ViewController 被 pop 或 dismiss 一小段时间后，看看该 UIViewController，它的 view，view 的 subviews 等等是否还存在。 因此，MLeaksFinder为基类 NSObject 添加一个方法 -willDealloc 方法，该方法的作用是，先用一个弱指针指向 self，并在一小段时间(2秒)后，通过这个弱指针调用 -assertNotDealloc，而 -assertNotDealloc 主要作用是直接中断言。ViewController执行viewDidDisappear后，如果两秒后对象释放，strongSelf为nil，若不为nil, 则认为当前对象发生了内存泄漏 12345678910111213- (BOOL)willDealloc &#123; __weak id weakSelf = self; dispatch_after(...2s..., ^&#123; __strong id strongSelf = weakSelf; //ViewController执行viewDidDisappear后，如果两秒后对象释放，strongSelf为nil，否则认为当前对象发生了内存泄漏 [strongSelf assertNotDealloc]; &#125;); return YES;&#125;- (void)assertNotDealloc &#123; NSAssert(NO, @“”);&#125; 这样，当我们认为某个对象应该要被释放了，在释放前调用这个方法，如果2秒后它被释放成功，weakSelf 就指向 nil，不会调用到 -assertNotDealloc 方法，也就不会中断言，如果它没被释放（泄露了），-assertNotDealloc 就会被调用中断言。这样，当一个 UIViewController 被 pop 或 dismiss 时（我们认为它应该要被释放了），我们遍历该 UIViewController 上的所有 view，依次调 -willDealloc，若3秒后没被释放，就会中断言。 ·手动扩展MLeaksFinder不仅可以检测 ViewController 跟 View 对象。MLeaksFinder 提供了一个手动扩展的机制，可以在UIViewController中检测其它类型的对象的内存泄露。如下所示，我们可以检测 UIViewController 底下的 View Model： 1234567- (BOOL)willDealloc &#123; if (![super willDealloc]) &#123; return NO; &#125; MLCheck(self.viewModel); return YES;&#125; 这里的原理跟上面的是一样的，宏 MLCheck() 做的事就是为传进来的对象建立 View-ViewController stack 信息，并对传进来的对象调用 -willDealloc 方法。 2. 源码分析","categories":[],"tags":[]},{"title":"OC 关键字分析","slug":"OC 关键字分析","date":"2019-03-21T06:29:19.000Z","updated":"2020-04-25T23:58:50.109Z","comments":true,"path":"2019/03/21/OC 关键字分析/","link":"","permalink":"https://tangzeng.github.io/2019/03/21/OC 关键字分析/","excerpt":"","text":"1: weak 和 __unsafe_unretainedweak 和 __unsafe_unretained 一样，表示的是对象的一种弱引用关系，唯一的区别是：weak修饰的对象被释放后，指向对象的指针会置空，也就是指向nil,不会产生野指针；而__unsafe_unretained修饰的对象被释放后，指针不会置空，而是变成一个野指针，那么此时如果访问这个对象的话，程序就会Crash，抛出BAD_ACCESS的异常。 那为什么有weak还要用__unsafe_unretained呢？ weak只支持iOS 5.0和OS X Mountain Lion作为部署版本（当然对于现在，这个原因已经可以无视了） weak对性能会有一定的消耗，使用weak,需要检查对象是否被释放，在追踪是否被释放的时候当然需要追踪一些信息，那么此时unsafe_unretained比weak快，而且一个对象有大量的weak引用对象的时候，当对象被废弃，那么此时就要遍历weak表，把表里所有的指针置空，消耗cpu资源。 什么时候使用unsafe_unretained呢？ 当你明确对象的生命周期的时候，可以使用unsafe_unretained替代weak,可以稍微提高一些性能，虽然这点性能微乎其微。 2. extern、static、const一、const与宏的区别: const简介:之前常用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。 编译时刻:宏是预编译（编译之前处理），const是编译阶段。 编译检查:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。 宏的好处:宏能定义一些函数，方法。 const不能。 宏的坏处:使用大量宏，容易造成编译时间久，每次都需要重新替换。 const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝 编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率比宏定义要高 二、const的使用:const有条原则, 那就是他右边是什么, 什么就不可变 const不可变原则：用const修饰函数的形参, 则能提高代码的安全性, 同时减少程序员之间的沟通成本 三、static和extern简单使用 static作用: 修饰局部变量： 1.延长局部变量的生命周期,程序结束才会销毁。 2.局部变量只会生成一份内存,只会初始化一次。 3.改变局部变量的作用域。 修饰全局变量 1.只能在本文件中访问,修改全局变量的作用域,生命周期不会改 2.避免重复定义全局变量 extern作用: 只是用来获取全局变量(包括全局静态变量)的值，不能用于定义变量 extern工作原理: 先在当前文件查找有没有全局变量，没有找到，才会去其他文件查找。 1234567891011121314151617181920212223// 全局变量：只有一份内存，所有文件共享，与extern联合使用。int a = 20;// static修饰全局变量static int age = 20;- (void)test&#123; // static修饰局部变量 static int age = 0; age++; NSLog(@&quot;%d&quot;,age);&#125;- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. [self test]; [self test]; extern int age; NSLog(@&quot;%d&quot;,age);&#125; 四、static与const联合使用 static与const作用:声明一个只读的静态变量 开发使用场景:在一个文件中经常使用的字符串常量，可以使用static与const组合 123456789101112131415161718192021// 开发中常用static修饰全局变量,只改变作用域// 为什么要改变全局变量作用域，防止重复声明全局变量。// 开发中声明的全局变量，有些不希望外界改动，只允许读取。// 比如一个基本数据类型不希望别人改动// 声明一个静态的全局只读常量static const int a = 20;// staic和const联合的作用:声明一个静态的全局只读常量// iOS中staic和const常用使用场景，是用来代替宏，把一个经常使用的字符串常量，定义成静态全局只读变量.// 开发中经常拿到key修改值，因此用const修饰key,表示key只读，不允许修改。static NSString * const key = @&quot;name&quot;;// 如果 const修饰 *key1,表示*key1只读，key1还是能改变。static NSString const *key1 = @&quot;name&quot;; 五、extern与const联合使用 开发中使用场景:在多个文件中经常使用的同一个字符串常量，可以使用extern与const组合。 原因: static与const组合：在每个文件都需要定义一份静态全局变量。 extern与const组合: 只需要定义一份全局变量，多个文件共享。 全局常量正规写法:开发中便于管理所有的全局变量，通常搞一个GlobeConst文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。 GlobeConst.h 12345/*******************************首页****************************/extern NSString * const nameKey = @&quot;name&quot;;/*******************************首页****************************/ GlobeConst.m 12345678#import &lt;Foundation/Foundation.h&gt;/*******************************首页****************************/NSString * const nameKey = @&quot;name&quot;;/*******************************首页****************************/ 3 #define宏定义主要分为对象宏和函数宏。宏定义在预编译阶段进行替换，不做类型检查。因此，宏定义的使用过程中有很多坑，尤其是在函数宏中。如果没有足够的功底，不要轻易写函数宏，否则会有惊喜。有关宏的深入了解，可以看一下喵神的宏定义的黑魔法 - 宏菜鸟起飞手册。 宏定义可以提升代码的优雅度，但也不能滥用。像上文中说的，一些”key”或者”notificationName”最好定义为静态常量。建议，将系统主题配置的数据定义为对象宏，例如主题色、字体大小、高度等，方便修改和使用；将常用并且冗长的 API 调用定义为函数宏，例如屏幕大小、系统版本判断等，用起来简洁、方便，减少大量冗余代码。 define 和 const的区别: 编译处理过程的区别： define宏在预处理阶段进行展开、替换，define宏没有类型，不做类型安全检查。宏定义是在预处理阶段进行替换，大量使用宏定义会造成编译时间过长。；const 常量在编译阶段使用，有具体类型，在编译阶段会进行类型检查。也就是说你用 define 定义一个字符串类型，然后赋值给一个浮点型变量，在编译阶段是不会报错的。但是现在的一些 IDE 都会有提示，例如 Xcode 就会提示对应错误。 编译四个大体步骤：预处理-&gt;编译-&gt;汇编-&gt;链接 内存管理方式的区别正如很多文章里说的那样，宏定义不分配内存，变量定义分配内存。宏定义给出的是立即数，每有一次替换，变会分配一次内存，在内存中有若干个拷贝；const 常量给出的是内存地址，存储在全局静态区，只有一次拷贝，一份内存，效率要比宏定义高 修饰区别define宏可以定义常量，也可以定义方法；const只能用来定义常量，不能用来修饰方法 4 __typeof__() &amp; __typeof()__typeof__()和__typeof()是对c语言的编译扩展，因为标准的c没有包含这样的操作符。标准c要求会对带有双下划线进行编译器预处理，这也是为什么我们在命名自己的方法和变量的时候不能用双下划线。 typeof()准确来讲是和上面两者相同，只是更加强调了这个特性，而这个特性是几乎每一个现代编译器都支持的。typeof()也是对c的扩展，如果用Objective-c写代码，将会用Clang编译器。 Clang是不支持typeof()的使用，但是从技术上讲，他是在c语法被设置为gnu类型会起作用。然而__typeof__()是支持c和gnu语法。如果用Xcode作为IDE，默认为c语法设置的是GNU99，而且&#39;asm&#39; &#39;inline&#39; &#39;typeof&#39;选项是YES。所以使用typeof()不会有任何问题。如果想更为安全的使用Clang编译器，那么就使用__typeof__()。这样的话就不会当你有人关掉typeof选项的时候造成的影响。 5 id &amp; instancetypeid 被称为”万能指针”，可以指向任何对象，可以用于任何类型的对象。由 id 关键字定义的对象，在编译器看来只是一个对象指针，关于对象的信息，需要等到运行时才能确定。也就是说，id 定义的对象不做类型检查，向它发送未知的消息，编译阶段不会报错。id 在 OC 中如下定义： 123456789101112#if !OBJC_TYPES_DEFINED/// Class 是一个 objc_class 结构体指针.typedef struct objc_class *Class;/// objc_object 结构体,里面是一个 Class 类型成员.struct objc_object &#123; Class isa OBJC_ISA_AVAILABILITY;&#125;;/// id 为一个 objc_object 结构体指针.typedef struct objc_object *id;#endif 从上面代码可以看出，id 本质是一个结构体指针，结构体中只有一个成员 isa。任何一个 OC 对象，都会带一个默认的 isa 指针来存储对象的具体类型和信息。 从 clang3.5 开始，出现类 instancetype 关键字。它可以表示一个方法的相关返回类型，与 id 不同的是，instancetype 返回是相关类的具体类型，编译器可以清楚的明确该类的信息，在调用该类的方法和属性时会进行检查。目前一般类的初始化方法，返回类型都为 instancetype。 6 #include &amp; #import &amp; @class &amp; @import1.#include在编译预处理阶段，预处理器会将一些引入的头文件替换成其对应的内容。例如，在源文件中引入了如下代码： 1#import &lt;Foundation/Foundation.h&gt; 预处理器对这行代码的处理是用 Foundation.h 文件中的内容去替换这行代码，如果 Foundation.h 中也引用了其他头文件，例如 #import &lt;Foundation/NSArray.h&gt;，则会按照同样的处理方式对引入的头文件进行逐级替代，依次递归下去。 在 C/C++ 中，我们用 #include 引入头文件，用 #include &quot;&quot; 引入自定义头文件，用 #include &lt;&gt; 引入系统头文件。使用双引号 &quot;&quot;，系统会优先从自定义头文件去查找，找不到再去系统头文件中找，如果还找不到，编译报错；使用尖括号 &lt;&gt;，系统会直接从系统头文件找，找不到会报错。如果直接用尖括号引入自定义头文件，则会直接报错。使用合理的方式去引入头文件，能够提高编译效率。 2.#import#import 可以说是 #include 的一个升级，有关 &quot;&quot; 和 &lt;&gt; 的使用与 #include 相同。除此之外，#import 解决了”重复引用“的问题。例如，A,B,C 三个文件，B 引用了 A，C 引用了 B 和 A，这时 C 相当于引用了两次 A。如果直接用 #include 编译会出问题，如果想使用 #include 应该这样写： 1234567891011#ifndef(XXX) #define XXX#endif例如：#ifndef _AFNETWORKING_ #define _AFNETWORKING_ #import &quot;AFURLRequestSerialization.h&quot; #import &quot;AFURLResponseSerialization.h&quot;#endif 如果直接使用 #import，可以避免这个重复引用的问题。在编译的时候它会进行判断，如果已经引入了就不会再次引入。最好的习惯还是尽量不要在头文件(.h)中引入过多的文件，以免加长编译时间。另外，在引入系统文件或者 Pod 中的文件时，最好将包含头文件的外层文件夹一起引入。如果不引入，虽然编译能够通过，但是 Xcode 会提示一些错误，而且调用里面 API 时不会有代码提示。例如： 1#import &lt;AVFoundation/AVFoundation.h&gt; // 前面添加 AVFoundation 文件夹 3.@class@class 是告诉编译器有这样一个类，但是具体这个类里面有什么不知道。好比只给了你一本书的目录，但是没有给你书的内容。那么什么情况下使用 @class 呢？在编译预处理阶段，会将文件中的 .h 文件替换为对应的内容，如果 .h 文件中还引入了其他的 .h 文件，则进行逐级替换，依次递归。因此，尽量不要在 .h 文件中引入其他的 .h 文件。如果在声明一下方法或者属性时，需要用到某个类，这时可以用 @class，并且需要在 .m 文件中以 #improt 的方式再次引入这个文件。代码如下： 12345678910111213// .h 文件中#import &lt;UIKit/UIKit.h&gt;@class UserModel;@interface ViewController : UIViewcontroller- (instancetype)initWithUserModel:(UserModel *)userModel; // 此处用到了 UserModel 定义参数类型@end// .m 文件中#import &quot;UserModel.h&quot;@implementation // 在这里需要使用 UserModel 中的具体内容，此时需要以 #import 的方式引入。@end 上面说过，@class 只是告诉有这么一个类，如果使用类中的内容，则会出错。 123456789101112131415// TestOne.htypedef NS_EUMU(NSInteger, ReachabilityStatus) &#123; ReachabilityStatusUnknown = -1, ReachabilityStatusNotReachable = 0, ReachabilityStatusReachableViaWWAN = 1, ReachabilityStatusReachableViaWiFi = 2,&#125;// OtherClass.h@class TestOne;@interface OtherClass : NSObject- (void)JudgeStatusWith:(ReachabilityStatus)status; // 这里使用 ReachabilityStatus 会报错@end 4.@import在说和这个关键字之前，先说一下 Moudles。#import 相对于 #include 解决了重复引用的问题，但同时也带来另外一个问题：当引用关系很复杂时，编译时引用所占的代码量就会大幅上升。如果想解决这个问题，可以在项目文件中的 Supporting Files 组内的 .pch 文件中将经常引用的一些头文件添加进去，解决编译时间问题。默认情况下，里面会引入 UIKit，这是每个文件中经常引用到的文件。 但是并不能把所有的文件都放到 .pch 文件中，因为放入 .pch 中的头文件，每个文件都能访问，这样有些文件就能访问它本不应该访问的文件。 为了解决这个问题，Moudles 出现了。Modules 相当于将框架进行了封装，然后加入在实际编译之时加入了一个用来存放已编译添加过的 Modules 列表。如果在编译的文件中引用到某个 Modules 的话，将首先在这个列表内查找，找到的话说明已经被加载过则直接使用已有的；如果没有找到，则把引用的头文件编译后加入到这个表中。这样被引用到的 Modules 只会被编译一次，提升速度，从而解决了编译时间和访问混乱的问题。 Apple 在 LLVM5.0 引入了一个新的编译符号 @import，使用 @ 符号将告诉编译器去使用 Modules 的引用形式。 1234#import &lt;Foundation/FoundationErrors.h&gt;// 下面等价于 #import &lt;UIKit/UIKit.h&gt;，同时还增加了 Moudles 的特性。@import Foundation.FoundationErrors;","categories":[],"tags":[]},{"title":"RunLoop的理解","slug":"runloop","date":"2019-02-21T06:29:19.000Z","updated":"2020-04-25T23:58:50.110Z","comments":true,"path":"2019/02/21/runloop/","link":"","permalink":"https://tangzeng.github.io/2019/02/21/runloop/","excerpt":"","text":"1：RunLoop 是什么Run Loop 是一个 iOS 开发里的基础概念，对应了其他操作系统中的Event Loop, 查阅 wikipedia 有关 Event Loop 的描述: 在计算机科学里， Event Loop / Run Loop 是一个用于等待和发送消息/事件的程序结构，在程序中等待和派发一系列事件或者消息。它通过向“事件提供者”发出请求来工作，通常会阻塞请求，直到事件到达，然后调用相应的事件处理程序。 Event Handler: 当 Event 被放到 Event Loop 里进行处理的时候，会调用预先注册过的代码对 Event 做处理。这就叫 Event Handler 。其实就是对 Event 的响应，也可以叫做事件回调. Event Loop 解决了什么问题同步操作，是一个接一个的处理。等前一个处理完，再执行下一个。那么在一些耗时任务上，比如有很多 I/O 操作 或者 网络请求 的任务，线程就会有长时间在等待任务结果。异步操作，是不用等待执行结果的，可以直接在这期间执行另外的任务。等到任务结果出来之后，再进行处理。实际上 Event Loop 就是实现异步的一种方法。 对于有回调的 Event,线程不用一直等待任务的结果出来再去执行下一个。而是等 Event 被加入到 Event Loop 时，再去执行。如果一个 Event 也没有，那线程就会休眠，避免浪费资源。如果没有 Event Loop 来实现异步操作，那我们的程序会很容易出现卡顿。RunLoop 源码阅读 RunLoop 的具体作用为什么要有Runloop呢？Runloop主要由以下几个方面的作用：1、使程序一直运行并接受用户输入：我们的app必然不能像命令式执行一样，执行完就退出了，我们需要app在我们不杀死它的时候一直运行着，并在由用户事件的时候能够响应，比如网络输入，用户点击等等，这是Runloop的首要任务；2、决定程序在何时应该处理哪些事件：实际上程序会有很多事件，Runloop会有一定的机制来管理时间的处理时机等；3、调用解耦（Message Queue）：比方说手指点击滑动会产生UIEvent事件，对于主调方来说，我不可能等到这个事件被执行了才去产生下一个事件，也就是主调方不能被被调方卡住。那么在实际实现中，被调方会有一个消息队列，主调方会把消息扔到消息队列中，然后不管了，消息的处理是由被调方不断去从消息队列中取消息，然后执行的。这样的好处是主调方不需要知道消息是具体是怎么执行的，只要产生消息即可，从而实现了解耦；4、节省CPU时间：在app没设可干的时候，让CPU闲着。Runloop机制并不是iOS特有的，Android和Windows上面都有，只要有这种需要接受事件的程序都有这种实现机制，只是其他平台上面不叫Runloop而已。细节可以参考 3：RunLoop 的实现原理(源码分析)3.1 RunLoop的封装结构OSX/iOS 系统中，提供了两个这样的对象：NSRunLoop 和 CFRunLoopRef。CFRunLoopRef 是在 CoreFoundation 框架内的，它提供了纯 C 函数的 API，所有这些 API 都是线程安全的。NSRunLoop 是基于 CFRunLoopRef 的封装，提供了面向对象的 API，但是这些 API 不是线程安全的。RunLoop 对外的接口在 CoreFoundation 里面关于 RunLoop 有5个类: CFRunLoopRefCFRunLoopModeRefCFRunLoopSourceRefCFRunLoopTimerRefCFRunLoopObserverRef 其中 CFRunLoopModeRef 类并没有对外暴露，只是通过 CFRunLoopRef 的接口进行了封装。他们的关系如下:一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source/Timer/Observer。每次调用 RunLoop 的主函数时，只能指定其中一个 Mode，这个Mode被称作 CurrentMode。如果需要切换 Mode，只能退出 Loop，再重新指定一个 Mode 进入。这样做主要是为了分隔开不同组的 Source/Timer/Observer，让其互不影响。 CFRunLoopSourceRef 是事件产生的地方。Source有两个版本：Source0 和 Source1。• Source0 只包含了一个回调（函数指针），它并不能主动触发事件。使用时，你需要先调用 CFRunLoopSourceSignal(source)，将这个 Source 标记为待处理，然后手动调用 CFRunLoopWakeUp(runloop) 来唤醒 RunLoop，让其处理这个事件。• Source1 包含了一个 mach_port 和一个回调（函数指针），被用于通过内核和其他线程相互发送消息。这种 Source 能主动唤醒 RunLoop 的线程，其原理在下面会讲到。 CFRunLoopTimerRef 是基于时间的触发器，它和 NSTimer 是toll-free bridged 的，可以混用。其包含一个时间长度和一个回调（函数指针）。当其加入到 RunLoop 时，RunLoop会注册对应的时间点，当时间点到时，RunLoop会被唤醒以执行那个回调。 CFRunLoopObserverRef 是观察者，每个 Observer 都包含了一个回调（函数指针），当 RunLoop 的状态发生变化时，观察者就能通过回调接受到这个变化。可以观测的时间点有以下几个： 12345678typedef CF_OPTIONS(CFOptionFlags, CFRunLoopActivity) &#123; kCFRunLoopEntry = (1UL &lt;&lt; 0), // 即将进入Loop kCFRunLoopBeforeTimers = (1UL &lt;&lt; 1), // 即将处理 Timer kCFRunLoopBeforeSources = (1UL &lt;&lt; 2), // 即将处理 Source kCFRunLoopBeforeWaiting = (1UL &lt;&lt; 5), // 即将进入休眠 kCFRunLoopAfterWaiting = (1UL &lt;&lt; 6), // 刚从休眠中唤醒 kCFRunLoopExit = (1UL &lt;&lt; 7), // 即将退出Loop&#125;; 上面的 Source/Timer/Observer 被统称为 mode item，一个 item 可以被同时加入多个 mode。但一个 item 被重复加入同一个 mode 时是不会有效果的。如果一个 mode 中一个 item 都没有，则 RunLoop 会直接退出，不进入循环。 4：应用","categories":[],"tags":[]},{"title":"转载 WWDC 2018：iOS 内存深入研究","slug":"转载WWDC-2018：iOS-内存深入研究","date":"2019-02-15T06:29:19.000Z","updated":"2020-04-25T23:58:50.110Z","comments":true,"path":"2019/02/15/转载WWDC-2018：iOS-内存深入研究/","link":"","permalink":"https://tangzeng.github.io/2019/02/15/转载WWDC-2018：iOS-内存深入研究/","excerpt":"","text":"完全摘自下文，只为记录用 WWDC 2018 Session 416：iOS Memory Deep Dive 引言对于我们的 App 所依赖的设备而言，内存资源是有限的。降低 App 所使用的内存可以提高性能和体验，相反，过大的内存占用可能会导致 App 被系统强制退出。所以每个 iOS 开发者都应该关注内存问题。这一节新的内容不多，基本上都是一些老的知识点。 按照 Session 的套路，我们先看一下提纲： 为什么要减少内存使用 内存占用 分析内存占用工具 图像 在后台时，对内存优化 演示 Demo 那我们就按顺序开始啦！ 为什么要减少内存在探讨内存之前，我们要知道为什么要减少内存。简单的回答是可以有更好的用户体验：更快的启动速度，不会因为内存过大而导致 Crash，可以让 App 存活更久等。 内存占用并非所有 App 的内存占用都是相同的。在继续探讨 iOS 上 App 的内存使用之前，我们先来聊一下Pages Memory。 Pages Memory内存是由系统管理，一般以页为单位来划分。在 iOS 上，每一页包含 16KB 的空间。一段数据可能会占用多页内存，所占用页总数乘以每页空间得到的就是这段数据使用的总内存。 内存页按照各自的分配和使用状态，可以被分为 Clean 和 Dirty 两类。 以上面的代码为例，申请一块长度为 80000 字节的内存空间，按照一页 16KB 来计算，就需要 6 页内存来存储。 当这些内存页开辟出来的时候，它们都是 Clean 的 当向处于第一页的内存写入数据时，第一页内存会变成 Dirty 当向处于最后一页的内存写入数据时，这一页也会变成 Dirty 内存映射文件当 App 访问一个文件时，系统内核会负责调度，将磁盘上的文件加载并映射到内存中。如果这是只读的文件，它所占用到的内存页是 Clean 的。 如下图所示，一个 50KB 的图片被加载到内存中时，需要分配 4 页内存来存储。其中第四页中有 2KB 的空间会被用来存储这个图片的数据，剩余空间可能会被用来存储其它数据。 典型app内存类型当内存不足的时候，系统会按照一定策略来腾出更多空间供使用，比较常见的做法是将一部分低优先级的数据挪到磁盘上，这个操作称为 Page Out。之后当再次访问到这块数据的时候，系统会负责将它重新搬回内存空间中，这个操作称为 Page In。 然而对于移动设备而言，频繁对磁盘进行IO操作会降低存储设备的寿命。从 iOS7 开始，系统开始采用压缩内存的办法来释放内存空间，被压缩的内存称为 Compressed Memory。下面依次介绍一下 iOS App 通常情况下的三种内存类型：Clean Memory 、Dirty Memory以及Compressed Memory。 Clean MemoryClean Memory 是指那些可以用以 Page Out 的内存，包括已被加载到内存中的文件，或者是 App 所用到的 frameworks。每个 frameworks 都有 _DATA_CONST 段，当 App 在运行时使用到了某个 framework，它所对应的 _DATA_CONST 的内存就会由 Clean 变为 Dirty。 Dirty MemoryDirty Memory 是指那些被 App 写入过数据的内存，包括所有堆区的对象、图像解码缓冲区，同时，类似 Clean memory，也包括 App 所用到的 frameworks。每个 framework 都会有 _DATA段和 _DATA_DIRTY 段，它们的内存是 Dirty 的。 值得注意的是，在使用 framework 的过程中会产生 Dirty Memory，使用单例或者全局初始化方法是减少 Dirty Memory 不错的方法，因为单例一旦创建就不会销毁，全局初始化方法会在 class 加载时执行。 Compressed Memory当内存吃紧的时候，系统会将不使用的内存进行压缩，直到下一次访问的时候进行解压。 例如，当我们使用 Dictionary 去缓存数据的时候，假设现在已经使用了 3 页内存，当不访问的时候可能会被压缩为 1 页，再次使用到时候又会解压成 3 页。 Memory Warnings并非所有内存警告都是由 App 造成的，例如在内存较小的设备上，当你接听电话的时候也有可能发生内存警告。按照以往的习惯，你可能会在收到内存警告通知的时候去做一些释放内存的事情。然而内存压缩机制会使事情变得复杂。我们来看看这个例子： 假设代码中的 cache 已被压缩过 事实上，当你尝试去再次访问 cache 对象的时候，系统会先解压这块内存 这个过程中内存使用会增加，在内存吃紧的时候，这并不是我们想要的。随后，当我们会执行大量工作去清空 cache，最终得到的内存空间和内存压缩的结果一样 所以，相比以往的缓存手段，更加建议去调整策略，例如减少缓存使用，或者在收到内存警告的时候，将这类事情交由系统去处理。 Caching我们对数据进行缓存的目的是想减少 CPU 的压力，但是过多的缓存又会占用过大的内存。由于内存压缩机制的存在，我们需要根据缓存数据大小以及重算这些数据的成本，在 CPU 和内存之间进行权衡。 在一些需要缓存数据的场景下，可以考虑使用 NSCache 代替 NSDictionary，因为 NSCache 可以自动清理内存，在内存吃紧的时候会更加合理。 小结通常情况下，我们所说的内存占用是指 Dirty Memory 和 Compressed Memory，Clean Memory 不需要过多关心。 App 能使用比较多的内存空间，但是上限会根据设备不同而不同。Extension 能使用的最大内存则要低很多，所以当你在开发 Extension 的时候尤其要注意内存使用。当使用的内存超出限制的时候，系统会抛出 EXC_RESOURCE_EXCEPTION 异常。 分析内存占用工具Xcode Memory Gauge 在 Xcode 中，你可以通过 Memory Gauge 工具，很方便快速的查看 App 运行时的内存情况，包括内存最高占用、最低占用，以及在所有进程中的占用比例等。如果想要查看更详细的数据，就需要用到 Instruments 了。 Instruments 在 Instruments 中，你可以使用 Allocations、Leaks、VM Tracker 和 Virtual Memory Trace 对 App 进行多维度分析。 Debug Debugger-Memory Resource Exceptions当你使用 Xcode 10 以前的版本进行调试时，在内存过大时，debug session 会直接终止，并且在控制台打印出异常。从 Xcode 10 开始，debugger 会自动捕获 EXC_RESOURCE RESOURCE_TYPE_MEMORY 异常，并断点在触发异常抛出的地方，十分方便定位问题。 Xcode Memory Debugger 通过这个工具，可以很直观地查看内存中所有对象的内存使用情况，以及相互之间的依赖关系，对定位那些因为循环引用导致的内存泄露问题十分有帮助。 你也可以点击 File-&gt;Export Memory Graph 将其导出为 memgraph 文件，在命令行中使用 Developer Tool 对其进行分析。使用这种方式，你可以在任何时候对过去某时的 App 内存使用进行分析。 简单介绍一下相关的命令 vmmap - 查看虚拟内存 查看详细报告 vmmap xx.memgraph 查看摘要报告 vmmap –summary xx.memgraph 配合管道命令查看所有动态库的Ditry Pages的总和 vmmap -pages xxx.memgraph | grep ‘.dylib’ | awk ‘{sum += $6} END { print “Total Dirty Pages:”sum}’ 只显示CG image相关的数据 vmmap xx.memgraph | grep ‘CG image’ 更多使用方式请查看vmmap的文档 man vmmap leaks - 查看泄漏的内存 查看是否有内存泄露 leaks xx.memgraph 查看某处内存的泄漏 leaks –traceTree [内存地址] xx.memgraph 更多使用方式请查看 leaks 的文档 man leaks heap - 查看堆区内存 查看所有堆区对象的内存使用 heap xx.memgraph 默认情况下是按照对象数量进行排序，通常情况下它们不会造成什么内存问题。我们需要关心的是那些为数不多，却占用了大量内存的对象，这时候就可以增加参数 -sortBySize，按照内存占用大小顺序来查看所有堆区对象的内存使用 heap xx.memgraph -sortBySize 当确定是哪个类型的对象占用了太多内存之后，可以得到每个对象的内存地址 heap xx.memgraph -addresses all | ‘XXBigData’ 更多使用方式请查看 heap 的文档 man heap 有了这些对象的内存地址之后，我们还需要另一样工具帮助我们做下一步分析。 Enabling Malloc Stack Logging在 Product -&gt; Scheme -&gt; Edit Scheme -&gt; Diagnostics 中，开启 Malloc Stack 功能，建议使用 Live Allocations Only 选项 之后 lldb 会记录调试过程中对象创建的堆栈，配合 malloc_history 工具，就可以定位到那些占用了过大内存的对象是哪里创建的。 malloc_history - 查看内存分配历史 malloc_history xx.memgraph [address] malloc_history xx.memgraph –fullStacks [address] 更多使用方式请查看 malloc_history 的文档 man malloc_history 选择哪个工具？上面讲述了那么多的分析工具，那我们应该选择哪种工具呢？苹果的工程师帮我们做了如下整理： 大家可以根据上图所示，根据不同的需要进行选择。 图片对于 iOS 系统而言，绝大部分场景下哪类数据占内存最多呢？当然是图片！需要注意的是，图片所占内存的大小与图片的尺寸有关，而不是图片的文件大小。 例如：有一个 590KB 的图片，分辨率是 2048px 1536px，它实际使用的内存不是 590KB，而是`2048 1536 * 4 = 12 MB`。。 图片为什么会占用这么大的内存呢，这还要从图片在 iOS 上显示的原理说起，具体可移步到 WWDC 2018 Session 219：Image and Graphics Best Practices，也可以直接阅读小伙伴前几天刚发布的文章 WWDC2018 图像最佳实践 图片的格式 sRGB：这个是目前比较通用的全色彩图像色域，每个像素占 4 个字节 Wide：每个像素占 8 个字节，相比 sRGB 能表示的颜色更多 还有占内存更小的格式： 亮度和 alpha 8 格式：每像素 2 个字节，单色图像和 alpha，metal 着色器。 Alpha 8 格式：每个像素 1 个字节，用于单色图像，比 SRGB 小 75％ 选择正确的格式可以减少了内存的使用。简单总结一下： 12345一个字节：Alpha 8两个字节：亮度和alpha 8四个字节：SRGB八个字节：Wide 格式复制代码 那下一个话题来了，如何选择正确的格式呢？ 选择正确的格式简单的回答是：不需要你来选择格式，而是应该让格式选择你。是不是觉得一下子松了一口气？哈哈😆 用 UIGraphicsImageRenderer 代替 UIGraphicsBeginImageContextWithOptions使用 UIGraphicsBeginImageContextWithOptions 生成的图片，每个像素需要 4 个字节表示。建议使用 UIGraphicsImageRenderer，这个方法是从 iOS 10 引入，在 iOS 12 上会自动选择最佳的图像格式，可以减少很多内存。 另外，如果想修改颜色，可以直接修改 tintColor，不会有额外的内存开销。 Downsampling当你缩小一幅图像的时候，会按照取平均值的办法把多个像素点变成一个像素点，这个过程称为 Downsampling。 UIImage 在设置和调整大小的时候，需要将原始图像加压到内存中，然后对内部坐标空间做一系列转换，整个过程会消耗很多资源。我们可以使用 ImageIO，它可以直接读取图像大小和元数据信息，不会带来额外的内存开销。 在后台时，对内存优化假设在 App 里展示了一张很大图片，当我们切换到后台去做其它的操作时，这个图片还在占用内存。我们应该考虑在合适的时机去回收这类占用过大的数据。 演示DemoDemo主要是用实际例子讲述了上面的知识点，这里就不再重复讲解了，感兴趣的童鞋可以移步 iOS Memory Deep Dive","categories":[],"tags":[]}]}