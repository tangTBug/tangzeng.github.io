	<!DOCTYPE HTML>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <title>OC 关键字分析 | BIGGILL</title>
  <meta name="author" content="BIGGILL">
  
  <meta name="description" content="平时的摘抄和自己的胡说八道">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="OC 关键字分析">
  <meta property="og:site_name" content="BIGGILL">

  
  
		<!-- favicon -->
		<link rel="apple-touch-icon" sizes="57x57" href="/apple-touch-icon-57x57.png">
		<link rel="apple-touch-icon" sizes="60x60" href="/apple-touch-icon-60x60.png">
		<link rel="apple-touch-icon" sizes="72x72" href="/apple-touch-icon-72x72.png">
		<link rel="apple-touch-icon" sizes="76x76" href="/apple-touch-icon-76x76.png">
		<link rel="apple-touch-icon" sizes="114x114" href="/apple-touch-icon-114x114.png">
		<link rel="apple-touch-icon" sizes="120x120" href="/apple-touch-icon-120x120.png">
		<link rel="apple-touch-icon" sizes="144x144" href="/apple-touch-icon-144x144.png">
		<link rel="apple-touch-icon" sizes="152x152" href="/apple-touch-icon-152x152.png">
		<link rel="icon" type="image/png" href="/favicon-32x32.png" sizes="32x32">
		<link rel="icon" type="image/png" href="/favicon-96x96.png" sizes="96x96">
		<link rel="icon" type="image/png" href="/favicon-16x16.png" sizes="16x16">
		<link rel="manifest" href="/manifest.json">
		<meta name="msapplication-TileColor" content="#009688">
		<meta name="msapplication-TileImage" content="/mstile-144x144.png">
		<meta name="theme-color" content="#009688">
		<!-- favicon end -->
    <!-- <link href="/favicon.ico" rel="icon"> -->
  

  <!-- toc -->
  <link rel="stylesheet" href="/libs/tocify/jquery.tocify.css" media="screen" type="text/css">

  <!-- <link rel="stylesheet" href="/libs/bs/css/bootstrap.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap/3.3.4/css/bootstrap.min.css" media="screen" type="text/css">

  <!-- material design -->
	<!-- <link rel="stylesheet" href="/libs/bs-material/css/ripples.min.css" media="screen" type="text/css"> -->
  <link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/ripples.min.css" media="screen" type="text/css">
  <!-- <link rel="stylesheet" href="/libs/bs-material/css/material.min.css" media="screen" type="text/css"> -->
	<link rel="stylesheet" href="//apps.bdimg.com/libs/bootstrap-material/0.3.0/css/material.min.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/highlight.light.css" media="screen" type="text/css">

  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  

  

  <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>
	<script>window.jQuery || document.write('<script src="/libs/jquery-2.0.3.min.js" type="text/javascript"><\/script>')</script>

</head>
</html>
 	<body>
	  <nav class="navbar navbar-default">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">菜单</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">BIGGILL</a>
        </div>
        <div id="navbar" class="collapse navbar-collapse">
            <ul class="nav navbar-nav navbar-right">
                
                <li>
                    <a href="/" title="">
                    <i class="fa fa-home"></i>首页
                    </a>
                </li>
                
                <li>
                    <a href="/archives" title="">
                    <i class="fa fa-list"></i>存档
                    </a>
                </li>
                
                <li>
                    <a href="/about" title="">
                    <i class="fa fa-info-circle"></i>关于
                    </a>
                </li>
                
                <li>
                    <a href="/atom.xml" title="这是一个订阅源">
                    <i class="fa fa-rss"></i>RSS
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</nav>

	  <div class="container" >
	    <div class="row">
	
	<div class="col-md-9 center-content">
	

		<div class="content">
			<!-- index -->
		   

			  		<h2>OC 关键字分析</h2>
					
					<div>
						<span class="post-time">2019-03-21 14:29:19</span>
					</div>	
					

					<div class="article-content">
						<h2 id="1-weak-和-unsafe-unretained"><a href="#1-weak-和-unsafe-unretained" class="headerlink" title="1: weak 和 __unsafe_unretained"></a>1: weak 和 __unsafe_unretained</h2><p><code>weak</code> 和 <code>__unsafe_unretained</code> 一样，表示的是对象的一种弱引用关系，唯一的区别是：<strong>weak修饰的对象被释放后，指向对象的指针会置空，也就是指向nil,不会产生野指针；而</strong><code>__unsafe_unretained</code>修饰的对象被释放后，指针不会置空，而是变成一个野指针，那么此时如果访问这个对象的话，程序就会Crash，抛出BAD_ACCESS的异常。</p>
<ul>
<li><p>那为什么有<code>weak</code>还要用<code>__unsafe_unretained</code>呢？</p>
<ul>
<li>weak只支持iOS 5.0和OS X Mountain Lion作为部署版本（当然对于现在，这个原因已经可以无视了）</li>
<li>weak对性能会有一定的消耗，使用<strong>weak,需要检查对象是否被释放，在追踪是否被释放的时候当然需要追踪一些信息，那么此时</strong>unsafe_unretained比<strong>weak快，而且一个对象有大量的</strong>weak引用对象的时候，当对象被废弃，那么此时就要遍历weak表，把表里所有的指针置空，消耗cpu资源。</li>
</ul>
</li>
<li><p>什么时候使用<strong>unsafe_unretained呢？</strong></p>
<p>当你明确对象的生命周期的时候，可以使用<strong>unsafe_unretained替代</strong>weak,可以稍微提高一些性能，虽然这点性能微乎其微。</p>
</li>
</ul>
<h2 id="2-extern、static、const"><a href="#2-extern、static、const" class="headerlink" title="2. extern、static、const"></a>2. extern、static、const</h2><h3 id="一、const与宏的区别"><a href="#一、const与宏的区别" class="headerlink" title="一、const与宏的区别:"></a>一、const与宏的区别:</h3><ul>
<li><p><code>const简介</code>:之前常用的字符串常量，一般是抽成宏，但是苹果不推荐我们抽成宏，推荐我们使用const常量。</p>
<ul>
<li><code>编译时刻</code>:宏是预编译（编译之前处理），const是编译阶段。</li>
<li><code>编译检查</code>:宏不做检查，不会报编译错误，只是替换，const会编译检查，会报编译错误。</li>
<li><code>宏的好处</code>:宏能定义一些函数，方法。 const不能。</li>
<li><code>宏的坏处</code>:使用大量宏，容易造成编译时间久，每次都需要重新替换。</li>
</ul>
<p>const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝</p>
<p>编译器通常不为普通const常量分配存储空间，而是将它们<code>保存在符号表</code>中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率比宏定义要高</p>
</li>
</ul>
<h3 id="二、const的使用"><a href="#二、const的使用" class="headerlink" title="二、const的使用:"></a>二、const的使用:</h3><p>const有条原则, 那就是<strong>他右边是什么, 什么就不可变</strong></p>
<p>const不可变原则：用const修饰函数的形参, 则能提高代码的安全性, 同时减少程序员之间的沟通成本</p>
<h3 id="三、static和extern简单使用"><a href="#三、static和extern简单使用" class="headerlink" title="三、static和extern简单使用"></a>三、static和extern简单使用</h3><ul>
<li><p>static作用: </p>
<ul>
<li><p>修饰局部变量：</p>
<p>1.延长局部变量的生命周期,程序结束才会销毁。</p>
<p>2.局部变量只会生成一份内存,只会初始化一次。</p>
<p>3.改变局部变量的作用域。</p>
</li>
<li><p>修饰全局变量</p>
<p>1.只能在本文件中访问,修改全局变量的作用域,生命周期不会改</p>
<p>2.避免重复定义全局变量</p>
</li>
</ul>
</li>
<li><p>extern作用: </p>
<ul>
<li>只是用来获取全局变量(包括全局静态变量)的值，不能用于定义变量</li>
</ul>
</li>
<li><p>extern工作原理: </p>
<ul>
<li>先在当前文件查找有没有全局变量，没有找到，才会去其他文件查找。</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// 全局变量：只有一份内存，所有文件共享，与extern联合使用。</span><br><span class="line">int a = 20;</span><br><span class="line"></span><br><span class="line">// static修饰全局变量</span><br><span class="line">static int age = 20;</span><br><span class="line"></span><br><span class="line">- (void)test</span><br><span class="line">&#123;</span><br><span class="line">    // static修饰局部变量</span><br><span class="line">    static int age = 0;</span><br><span class="line">    age++;</span><br><span class="line">    NSLog(@&quot;%d&quot;,age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view, typically from a nib.</span><br><span class="line">    [self test];</span><br><span class="line">    [self test];</span><br><span class="line">    </span><br><span class="line">    extern int age;</span><br><span class="line">    NSLog(@&quot;%d&quot;,age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、static与const联合使用"><a href="#四、static与const联合使用" class="headerlink" title="四、static与const联合使用"></a>四、static与const联合使用</h3><ul>
<li>static与const作用:声明一个只读的静态变量</li>
<li>开发使用场景:在<code>一个文件中</code>经常使用的字符串常量，可以使用static与const组合</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 开发中常用static修饰全局变量,只改变作用域</span><br><span class="line"></span><br><span class="line">// 为什么要改变全局变量作用域，防止重复声明全局变量。</span><br><span class="line"></span><br><span class="line">// 开发中声明的全局变量，有些不希望外界改动，只允许读取。</span><br><span class="line"></span><br><span class="line">// 比如一个基本数据类型不希望别人改动</span><br><span class="line"></span><br><span class="line">// 声明一个静态的全局只读常量</span><br><span class="line">static const int a = 20;</span><br><span class="line"></span><br><span class="line">// staic和const联合的作用:声明一个静态的全局只读常量</span><br><span class="line"></span><br><span class="line">// iOS中staic和const常用使用场景，是用来代替宏，把一个经常使用的字符串常量，定义成静态全局只读变量.</span><br><span class="line"></span><br><span class="line">// 开发中经常拿到key修改值，因此用const修饰key,表示key只读，不允许修改。</span><br><span class="line">static  NSString * const key = @&quot;name&quot;;</span><br><span class="line"></span><br><span class="line">// 如果 const修饰 *key1,表示*key1只读，key1还是能改变。</span><br><span class="line"></span><br><span class="line">static  NSString const *key1 = @&quot;name&quot;;</span><br></pre></td></tr></table></figure>
<h3 id="五、extern与const联合使用"><a href="#五、extern与const联合使用" class="headerlink" title="五、extern与const联合使用"></a>五、extern与const联合使用</h3><ul>
<li>开发中使用场景:在<code>多个文件中</code>经常使用的同一个字符串常量，可以使用extern与const组合。</li>
<li>原因: <ul>
<li>static与const组合：在每个文件都需要定义一份静态全局变量。</li>
<li>extern与const组合: 只需要定义一份全局变量，多个文件共享。</li>
</ul>
</li>
<li><p>全局常量正规写法:开发中便于管理所有的全局变量，通常搞一个GlobeConst文件，里面专门定义全局变量，统一管理，要不然项目文件多不好找。</p>
</li>
<li><p>GlobeConst.h</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*******************************首页****************************/</span><br><span class="line"></span><br><span class="line">extern NSString * const nameKey = @&quot;name&quot;;</span><br><span class="line"></span><br><span class="line">/*******************************首页****************************/</span><br></pre></td></tr></table></figure>
<ul>
<li>GlobeConst.m</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">/*******************************首页****************************/</span><br><span class="line"></span><br><span class="line">NSString * const nameKey = @&quot;name&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*******************************首页****************************/</span><br></pre></td></tr></table></figure>
<h2 id="3-define"><a href="#3-define" class="headerlink" title="3 #define"></a>3 #define</h2><p>宏定义主要分为<strong>对象宏</strong>和<strong>函数宏</strong>。宏定义在预编译阶段进行替换，不做类型检查。因此，宏定义的使用过程中有很多坑，尤其是在函数宏中。如果没有足够的功底，不要轻易写函数宏，否则会有惊喜。有关宏的深入了解，可以看一下喵神的<a href="https://onevcat.com/2014/01/black-magic-in-macro/" target="_blank" rel="noopener">宏定义的黑魔法 - 宏菜鸟起飞手册</a>。</p>
<p>宏定义可以提升代码的优雅度，但也不能滥用。像上文中说的，一些”key”或者”notificationName”最好定义为静态常量。建议，将系统主题配置的数据定义为对象宏，例如主题色、字体大小、高度等，方便修改和使用；将常用并且冗长的 API 调用定义为函数宏，例如屏幕大小、系统版本判断等，用起来简洁、方便，减少大量冗余代码。</p>
<ul>
<li><h4 id="define-和-const的区别"><a href="#define-和-const的区别" class="headerlink" title="define 和 const的区别:"></a>define 和 const的区别:</h4><ul>
<li><p><strong>编译处理过程的区别</strong>：</p>
<p> define宏在预处理阶段进行展开、替换，<strong>define宏没有类型</strong>，不做类型安全检查。宏定义是在预处理阶段进行替换，大量使用宏定义会造成编译时间过长。；const 常量在编译阶段使用，有具体类型，在编译阶段会进行类型检查。也就是说你用 define 定义一个字符串类型，然后赋值给一个浮点型变量，在编译阶段是不会报错的。但是现在的一些 IDE 都会有提示，例如 Xcode 就会提示对应错误。</p>
<p>编译四个大体步骤：预处理-&gt;编译-&gt;汇编-&gt;链接</p>
</li>
<li><p><strong>内存管理方式的区别</strong><br>正如很多文章里说的那样，宏定义不分配内存，变量定义分配内存。宏定义给出的是立即数，每有一次替换，变会分配一次内存，在内存中有若干个拷贝；const 常量给出的是内存地址，存储在全局静态区，只有一次拷贝，一份内存，效率要比宏定义高</p>
</li>
<li><p><strong>修饰区别</strong><br>define宏可以定义常量，也可以定义方法；const只能用来定义常量，不能用来修饰方法</p>
</li>
</ul>
</li>
</ul>
<h2 id="4-typeof-amp-typeof"><a href="#4-typeof-amp-typeof" class="headerlink" title="4 __typeof__() &amp; __typeof()"></a>4 <code>__typeof__()</code> &amp; <code>__typeof()</code></h2><p><code>__typeof__()</code>和<code>__typeof()</code>是对c语言的编译扩展，因为标准的c没有包含这样的操作符。标准c要求会对带有双下划线进行编译器预处理，这也是为什么我们在命名自己的方法和变量的时候不能用双下划线。</p>
<p><code>typeof()</code>准确来讲是和上面两者相同，只是更加强调了这个特性，而这个特性是几乎每一个现代编译器都支持的。<code>typeof()</code>也是对c的扩展，如果用<code>Objective-c</code>写代码，将会用<code>Clang</code>编译器。</p>
<p>Clang是不支持<code>typeof()</code>的使用，但是从技术上讲，他是在c语法被设置为<code>gnu</code>类型会起作用。然而<code>__typeof__()</code>是支持<code>c和gnu</code>语法。如果用Xcode作为IDE，默认为c语法设置的是<code>GNU99</code>，而且<code>&#39;asm&#39; &#39;inline&#39; &#39;typeof&#39;</code>选项是<code>YES</code>。所以使用<code>typeof()</code>不会有任何问题。如果想更为安全的使用<code>Clang</code>编译器，那么就使用<code>__typeof__()</code>。这样的话就不会当你有人关掉<code>typeof</code>选项的时候造成的影响。</p>
<h2 id="5-id-amp-instancetype"><a href="#5-id-amp-instancetype" class="headerlink" title="5 id &amp; instancetype"></a>5 id &amp; instancetype</h2><p>id 被称为”万能指针”，可以指向任何对象，可以用于任何类型的对象。由 id 关键字定义的对象，在编译器看来只是一个对象指针，关于对象的信息，需要等到运行时才能确定。也就是说，id 定义的对象不做类型检查，向它发送未知的消息，编译阶段不会报错。id 在 OC 中如下定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#if !OBJC_TYPES_DEFINED</span><br><span class="line">/// Class 是一个 objc_class 结构体指针.</span><br><span class="line">typedef struct objc_class *Class;</span><br><span class="line"></span><br><span class="line">/// objc_object 结构体,里面是一个 Class 类型成员.</span><br><span class="line">struct objc_object &#123;</span><br><span class="line">    Class isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">/// id 为一个 objc_object 结构体指针.</span><br><span class="line">typedef struct objc_object *id;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>从上面代码可以看出，id 本质是一个结构体指针，结构体中只有一个成员 <code>isa</code>。任何一个 OC 对象，都会带一个默认的 <code>isa</code> 指针来存储对象的具体类型和信息。</p>
<p>从 clang3.5 开始，出现类 <code>instancetype</code> 关键字。它可以表示一个方法的相关返回类型，与 <code>id</code> 不同的是，<code>instancetype</code> 返回是相关类的具体类型，编译器可以清楚的明确该类的信息，在调用该类的方法和属性时会进行检查。目前一般类的初始化方法，返回类型都为 <code>instancetype</code>。</p>
<h2 id="6-include-amp-import-amp-class-amp-import"><a href="#6-include-amp-import-amp-class-amp-import" class="headerlink" title="6 #include &amp; #import &amp; @class &amp; @import"></a>6 #include &amp; #import &amp; @class &amp; @import</h2><h4 id="1-include"><a href="#1-include" class="headerlink" title="1.#include"></a>1.#include</h4><p>在编译预处理阶段，预处理器会将一些引入的头文件替换成其对应的内容。例如，在源文件中引入了如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br></pre></td></tr></table></figure>
<p>预处理器对这行代码的处理是用 Foundation.h 文件中的内容去替换这行代码，如果 Foundation.h 中也引用了其他头文件，例如 <code>#import &lt;Foundation/NSArray.h&gt;</code>，则会按照同样的处理方式对引入的头文件进行逐级替代，依次递归下去。</p>
<p>在 C/C++ 中，我们用 <code>#include</code> 引入头文件，用 <code>#include &quot;&quot;</code> 引入自定义头文件，用 <code>#include &lt;&gt;</code> 引入系统头文件。使用双引号 <code>&quot;&quot;</code>，系统会优先从自定义头文件去查找，找不到再去系统头文件中找，如果还找不到，编译报错；使用尖括号 <code>&lt;&gt;</code>，系统会直接从系统头文件找，找不到会报错。如果直接用尖括号引入自定义头文件，则会直接报错。使用合理的方式去引入头文件，能够提高编译效率。</p>
<h4 id="2-import"><a href="#2-import" class="headerlink" title="2.#import"></a>2.#import</h4><p><code>#import</code> 可以说是 <code>#include</code> 的一个升级，有关 <code>&quot;&quot;</code> 和 <code>&lt;&gt;</code> 的使用与 <code>#include</code> 相同。除此之外，<code>#import</code> 解决了”重复引用“的问题。例如，A,B,C 三个文件，B 引用了 A，C 引用了 B 和 A，这时 C 相当于引用了两次 A。如果直接用 <code>#include</code> 编译会出问题，如果想使用 <code>#include</code> 应该这样写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#ifndef(XXX)</span><br><span class="line">　　#define XXX</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">#ifndef _AFNETWORKING_</span><br><span class="line">    #define _AFNETWORKING_</span><br><span class="line">    #import &quot;AFURLRequestSerialization.h&quot;</span><br><span class="line">    #import &quot;AFURLResponseSerialization.h&quot;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>
<p>如果直接使用 <code>#import</code>，可以避免这个重复引用的问题。在编译的时候它会进行判断，如果已经引入了就不会再次引入。最好的习惯还是尽量不要在头文件(.h)中引入过多的文件，以免加长编译时间。另外，在引入系统文件或者 Pod 中的文件时，最好将包含头文件的外层文件夹一起引入。如果不引入，虽然编译能够通过，但是 Xcode 会提示一些错误，而且调用里面 API 时不会有代码提示。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;AVFoundation/AVFoundation.h&gt;   // 前面添加 AVFoundation 文件夹</span><br></pre></td></tr></table></figure>
<h4 id="3-class"><a href="#3-class" class="headerlink" title="3.@class"></a>3.@class</h4><p><code>@class</code> 是告诉编译器有这样一个类，但是具体这个类里面有什么不知道。好比只给了你一本书的目录，但是没有给你书的内容。那么什么情况下使用 <code>@class</code> 呢？在编译预处理阶段，会将文件中的 .h 文件替换为对应的内容，如果 .h 文件中还引入了其他的 .h 文件，则进行逐级替换，依次递归。因此，<strong>尽量不要在 .h 文件中引入其他的 .h 文件</strong>。如果在声明一下方法或者属性时，需要用到某个类，这时可以用 <code>@class</code>，并且需要在 .m 文件中以 <code>#improt</code> 的方式再次引入这个文件。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// .h 文件中</span><br><span class="line">#import &lt;UIKit/UIKit.h&gt;</span><br><span class="line">@class UserModel;</span><br><span class="line"></span><br><span class="line">@interface ViewController : UIViewcontroller</span><br><span class="line">- (instancetype)initWithUserModel:(UserModel *)userModel;  // 此处用到了 UserModel 定义参数类型</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// .m 文件中</span><br><span class="line">#import &quot;UserModel.h&quot;</span><br><span class="line">@implementation </span><br><span class="line">// 在这里需要使用 UserModel 中的具体内容，此时需要以 #import 的方式引入。</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>上面说过，<code>@class</code> 只是告诉有这么一个类，如果使用类中的内容，则会出错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// TestOne.h</span><br><span class="line">typedef NS_EUMU(NSInteger, ReachabilityStatus) &#123;</span><br><span class="line">    ReachabilityStatusUnknown          = -1,</span><br><span class="line">    ReachabilityStatusNotReachable     = 0,</span><br><span class="line">    ReachabilityStatusReachableViaWWAN = 1,</span><br><span class="line">    ReachabilityStatusReachableViaWiFi = 2,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// OtherClass.h</span><br><span class="line">@class TestOne;</span><br><span class="line"></span><br><span class="line">@interface OtherClass : NSObject</span><br><span class="line">- (void)JudgeStatusWith:(ReachabilityStatus)status;   // 这里使用 ReachabilityStatus 会报错</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h4 id="4-import"><a href="#4-import" class="headerlink" title="4.@import"></a>4.@import</h4><p>在说和这个关键字之前，先说一下 <strong>Moudles</strong>。<code>#import</code> 相对于 <code>#include</code> 解决了重复引用的问题，但同时也带来另外一个问题：当引用关系很复杂时，编译时引用所占的代码量就会大幅上升。如果想解决这个问题，可以在项目文件中的 Supporting Files 组内的 .pch 文件中将经常引用的一些头文件添加进去，解决编译时间问题。默认情况下，里面会引入 <code>UIKit</code>，这是每个文件中经常引用到的文件。</p>
<p>但是并不能把所有的文件都放到 .pch 文件中，因为放入 .pch 中的头文件，每个文件都能访问，这样有些文件就能访问它本不应该访问的文件。</p>
<p>为了解决这个问题，Moudles 出现了。Modules 相当于将框架进行了封装，然后加入在实际编译之时加入了一个用来存放已编译添加过的 Modules 列表。如果在编译的文件中引用到某个 Modules 的话，将首先在这个列表内查找，找到的话说明已经被加载过则直接使用已有的；如果没有找到，则把引用的头文件编译后加入到这个表中。这样被引用到的 Modules 只会被编译一次，提升速度，从而解决了编译时间和访问混乱的问题。</p>
<p>Apple 在 LLVM5.0 引入了一个新的编译符号 <code>@import</code>，使用 @ 符号将告诉编译器去使用 Modules 的引用形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#import &lt;Foundation/FoundationErrors.h&gt;</span><br><span class="line"></span><br><span class="line">// 下面等价于 #import &lt;UIKit/UIKit.h&gt;，同时还增加了 Moudles 的特性。</span><br><span class="line">@import Foundation.FoundationErrors;</span><br></pre></td></tr></table></figure>

					</div>

			  <!-- about -->
			  
		</div>

		<!-- pagination -->
	  

		<div class="comment-section">
  
  


</div>
	</div>

	

</div>


		<footer>
			

<p>
  由 <a href="https://hexo.io">hexo</a> 强力驱动 | 搭载 <a href="https://github.com/wayou/hexo-theme-material">material</a> 主题
</p>
<p>
  &copy; 2020 <a href="https://tangzeng.github.io"> BIGGILL </a>
</p>
<a id="gotop" href="#" title="back to top"><i class="mdi-hardware-keyboard-arrow-up"></i></a>

		</footer>
	  </div>

		<!-- <script src="/libs/bs/js/bootstrap.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap/3.3.4/js/bootstrap.min.js"></script>
		<script>(typeof $().modal == 'function')|| document.write('<script src="/libs/bs/js/bootstrap.min.js" type="text/javascript"><\/script>')</script>

		<!-- material design -->
		<!-- <script src="/libs/bs-material/js/ripples.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/ripples.min.js"></script>
		<!-- <script src="/libs/bs-material/js/material.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/bootstrap-material/0.3.0/js/material.min.js"></script>
		<!-- toc -->
		<!-- <script src="/libs/tocify/jquery-ui.min.js"></script> -->
		<script src="//apps.bdimg.com/libs/jqueryui/1.10.4/jquery-ui.min.js"></script>
		<script src="/libs/tocify/jquery.tocify.custom.js"></script>

		<script src="/js/main.js"></script>

	</body>
</html>
